################################################################################
##         CONVEX HULL. Facet and vertex number. Empirical Estimations        ##
##          p-variate Gaussian and Poisson Models (p =1,..,5)                 ##
################################################################################


# Test description--------------------------------------------------------|
# We generate ts ~ N(O,Ip) (or P(1)) in dimension p = 1,.., 5                        
# with n = 2^(10:23) data points (without changes)  and estimate          |
# the number of vertices and facets of convex hull {P(ts_i)}_{i=1,..,n}   |
# by the functions from the package "geometry".                           |    
#-------------------------------------------------------------------------|

# Remark------------------------------------------------------------------|
# The test was performed using parallel computing on the server           |
# The number of cores: mc.cores = nbSimus_, where                         |
# nbSimus_ = 100 is the number of simulations.                            |
# The test results are saved in files of the following type:              |
# 'Fs_dim_p_gauss_nbSimus_.txt' (for facets) and                          |
# 'Vs_dim_p_poisson_nbSimus_.txt'(for vertices)                           |                                              
#-------------------------------------------------------------------------|

#packages----------------------------------------------------------------|

#install.packages("geometry")
library(geometry) 
library(parallel)

#functions----------------------------------------------------------------|

#' @title generate_ts Data generating function
#'
#' @description the function generates a time series of length 'n' in dimension 'p'
#' where each data point is generated by a distribution from the natural exponential family:
#' Gauss, Poisson or Pascal with a given values of means and changes.
#' 
#' @param type type of distribution: "gauss", "poisson".
#' @param n number of data points.
#' @param p parameter of dimension.
#' @param change index of change point ( 1 < change < n).
#' @param changes a vector of increasing change point indices (last element is always less then n).
#' By default, 'changes = NULL' (the data without change points).
#' @param means matrix of successive means for data
#' By default 'means = matrix(0, ncol = 1, nrow = p)'.
#' @param noise standard deviation of an additional normal noise
#' By default 'noise = 1' (use for Gaussian distribution).
#'
#' @return matrix of data of dimension n x p with a given values of theta and theta0 for the segments.
#'
#' @examples
#' set.seed(21)
#' N <- 100
#' P <- 2
#' Change <- N %/% 2
#' theta0 <-  rep(0, P)
#' ts_gauss <- generate_ts(type = "gauss", p = P, n = N, changes = Change, means = matrix(c(theta0, theta0 + 5), nrow = P))
#' ts_gauss0 <- generate_ts(type = "gauss", p = P, n = N, changes = NULL, means = matrix(0, ncol = 1, nrow = P))
generate_ts <- function(type, p, n, changes, means, noise = 1) {
  #parameter's check----------------------------- 
  if (!type %in% c("gauss", "poisson"))
    stop('Attention, type should be "gauss"  or "poisson"!')
  if (!is.null(changes) && n <= changes[length(changes)]) 
    stop('Attention, the last element of changepoints is always less than n!')
  if(!is.null(changes) && !is.numeric(changes)) 
    stop('Attention, changes are not all numeric!')
  if(is.unsorted(changes)) 
    stop('Attention, changes should be an increasing vector!')
  if(!is.numeric(means))
    stop('means are not all numeric!')
  if ((length(changes) + 1) !=  length(means[1,])) 
    stop('The length of the means[,] is always equal to the number of changes plus one!')
  if (!is.double(noise)) 
    stop('noise is not a double!')
  if (noise < 0) 
    stop('noise must be non-negative!')
  if (type == "poisson") 
    if (sum(means <= 0) != 0)
      stop('Attention, the value of means shold be positive!')
  #--------------------
  #data generation
  res <- matrix(0, n, p)
  for (i in 1:p) {
    parameters <- rep(means[i,], diff(c(0, changes, n)))
    if (type == "gauss")  res[, i] <- parameters + rnorm(n, 0, noise)
    if (type == "poisson") res[, i] <- rpois(n, parameters)
  }
  return(res)
}

#' @title getCHparameters
#'
#' @description function returns number of facets and vertices of convex hull of ts ~ P_p(1)
#'
#' @param cnst_ parameter for function set.seed
#' @param n_ number of data point of time series without changes.
#' @param p_ parameter of dimension.
#'
#' @return number of facets and vertices of convex hull of ts ~ N_p(O,1p).
#'
#' @examples
#'getCHparameters(cnst_ = 1, n_ = 2^10, p_ = 2)

getCHparameters <- function(cnst_, n_,p_, cost_, mean_) { 
  set.seed(cnst_ + 10)
  ts_ <- generate_ts(type = cost_,
                     p = p_,
                     n = n_,
                     changes = NULL,
                     means = matrix(mean_, ncol = 1, nrow = p_))
  get_CH_points <- apply(cbind(1, ts_), 2, cumsum)
  get_CH <- convhulln(get_CH_points)
  get_nb_of_facets <- dim(get_CH)[1]
  get_nb_of_vertices <- length(unique(as.vector(get_CH)))
  return (c(get_nb_of_facets, get_nb_of_vertices));
}

#parameters---------------------------------------------------------------|
degree <- 10:23
n_ <-2^(degree)
dim_ <- 1 : 5
#number of simulations
nbSimus_ <- 100
#Time limit
TimeLimit <- 2400# 40 min

cost <- c ('gauss','poisson')
mean <- c(0,1)
#calculations-------------------------------------------------------------|
for (cst in 1: length(cost)){
  for (p in 1 : length(dim_)) {
    get_n <- NULL
    get_res <- NULL
    get_fs <- NULL
    get_vs <- NULL
    
    index <- 1
    Time <- 0
    while ((index <= length(n_)) && (Time <= TimeLimit)) {
      N <- n_[index]
      Time <- max(Time, system.time(
        get_res <- do.call(cbind, parallel::mclapply(
          1:nbSimus_, function(i) getCHparameters(cnst_ = i,
                                                  n_ = N,
                                                  p_ = dim_[p],
                                                  cost_ = cost[cst],
                                                  mean_ = mean[cst]
          ), mc.cores = nbSimus_))
      )[3])
      get_n <- c(get_n, rep(N, nbSimus_) )
      get_fs <- c(get_fs,get_res[1,])
      get_vs <- c(get_vs,get_res[2,])
      
      index <- index + 1
    }
    #save
    write.table(data.frame (n = get_n, fs=get_fs), 
                paste('Fs_dim',dim_[p],cost[cst],nbSimus_,'.txt',sep = '_'),
                row.names = TRUE, col.names = FALSE)
    write.table(data.frame (n = get_n, vs=get_vs),
                paste('Vs_dim',dim_[p],cost[cst], nbSimus_,'.txt',sep = '_') , 
                row.names = TRUE, col.names = FALSE)
  }
}
################################################################################
########################### END ################################################
################################################################################
